"""This module contains vulnerability types, Enums, nodes and helpers."""

import json
from enum import Enum
from collections import namedtuple
from .source_sink_identify import Source_Param_Trigger, Source_Instr_Trigger, Source_Ret_Trigger, Sink_Trigger
import copy
from ipdb import set_trace
from collections import defaultdict

#from core.node_types import YieldNode


class VulnerabilityType(Enum):
    FALSE = 0
    SANITISED = 1
    TRUE = 2
    UNKNOWN = 3


def vuln_factory(vulnerability_type):
    if vulnerability_type == VulnerabilityType.UNKNOWN:
        return UnknownVulnerability
    elif vulnerability_type == VulnerabilityType.SANITISED:
        return SanitisedVulnerability
    else:
        return Vulnerability

# def _get_reassignment_str(reassignment_nodes):
#     reassignments = ''
#     if reassignment_nodes:
#         reassignments += '\nReassigned in:\n\t'
#         for node in reassignment_nodes:
#             result_left = "["
#             result_right = "["
#             for variable in node.left_hand_side:
#                 if result_left != "[":
#                     result_left += ", "
#                 result_left += variable.toString()
            
#             for variable in node.right_hand_side_variables:
#                 if result_right != "[":
#                     result_right += ", "
#                 result_right += variable.toString()
#             result_left += "]"
#             result_right += "]"

#             reassignments += '\n\t > pc: ' + str(node.pc) + '\t instr: ' + f"{result_left} = {result_right}"

#     return reassignments


class Vulnerability():
    def __init__(
        self,
        source,
        source_trigger_word,
        sink,
        sink_trigger_word,
        propagation_chain_list
    ):
        """Set source and sink information."""
        self.source = source
        self.source_trigger_word = source_trigger_word
        self.sink = sink
        self.sink_trigger_word = sink_trigger_word
        self.propagation_chain_list = propagation_chain_list
        self.sanitized_info = defaultdict(list)
        self.cmd = ""
        self.check_propagation_sanitized()


    def check_propagation_sanitized(self):
        """
            record the index info of propagation which has beed sanitized or not
        """
        # self.sanitized_info = defaultdict(list)
        for index, propagation_chain_dict in enumerate(self.propagation_chain_list):
            if propagation_chain_dict["type"] == VulnerabilityType.TRUE:
                self.sanitized_info["True"].append(index)
            elif propagation_chain_dict["type"] == VulnerabilityType.SANITISED:
                self.sanitized_info["Sanitized"].append(index)
            else:
                raise Exception("unexpected vulnerability type")

    def get_dsp_of_propagation(self, propagation_chain, santizer_record=None):
        dsp = ""
        if santizer_record:
            dsp += "\t Hit Sanitizer func in this chain\n"
            dsp += "\t sanitizer info:\n"
            for func_name, sanitiser_name in santizer_record.items():
                dsp += f"\t\t func_name:{func_name:<20}, sanitizer_name:{',' .join(sanitiser_name)}\n"
            dsp += "\n"
        if len(propagation_chain) == 1:
            # source and sink in the same function
            record = propagation_chain[0]
            dsp += "\t Source and Sink in the same function\n"
            # set_trace()
            dsp += "\t File: {}, Function: {}\n".format(record.cfg.lua_module.module_name, record.cfg._func_name)
            dsp += record.assignment_dsp
            return dsp
        else:
            for idx, record in enumerate(propagation_chain):
                if idx == 0:
                    dsp += "\t Source propagation\n"
                    dsp += "\t File: {}, Function: {}\n".format(record.cfg.lua_module.module_name, record.cfg._func_name)
                    dsp += record.assignment_dsp
                elif idx == len(propagation_chain) - 1:
                    dsp += "\t Sink propagation\n"
                    dsp += "\t File: {}, Function: {}\n".format(record.cfg.lua_module.module_name, record.cfg._func_name)
                    dsp += record.assignment_dsp
                else:
                    dsp += "\t intermidiate propagation\n"
                    dsp += "\t File: {}, Function: {}\n".format(record.cfg.lua_module.module_name, record.cfg._func_name)
                    dsp += record.assignment_dsp
            return dsp

    def get_exploiting_chain_info(self, sanitizer=False):
        dsp_list = list()
        for index in self.sanitized_info["True"]:
            propagation_chain_dict = self.propagation_chain_list[index]
            propagation_chain = propagation_chain_dict["propagation_chain"]
            dsp = self.get_dsp_of_propagation(propagation_chain)
            dsp_list.append(dsp)
        
        if not sanitizer:
            # set_trace()
            for index in self.sanitized_info["Sanitized"]:
                propagation_chain_dict = self.propagation_chain_list[index]
                propagation_chain = propagation_chain_dict["propagation_chain"]
                santizer_record = propagation_chain_dict["sanitizer"]
                dsp = self.get_dsp_of_propagation(propagation_chain, santizer_record)
                dsp_list.append(dsp)

        return dsp_list
        


    def get_all_chain_info(self, sanitiser=False):
        """Pretty printing of a vulnerability."""
        reassigned_dsp_list = self.get_exploiting_chain_info(sanitiser)
        reassigned_dsp_all = ""
        for idx, reassigned_dsp in enumerate(reassigned_dsp_list):
            reassigned_dsp_all += "\t No.{} propagation path\n".format(idx)
            reassigned_dsp_all += reassigned_dsp

        source_dsp = ""
        if isinstance(self.source, Source_Param_Trigger):
            source_dsp = f"function param idx: {self.source.param_idx}"
        elif isinstance(self.source, Source_Instr_Trigger):
            source_dsp = self.source.trigger_word
        elif isinstance(self.source, Source_Ret_Trigger):
            source_dsp = f"function return idx: {self.source.return_idx}"
        else:
            raise Exception("Source type unpected")
        return (
            'Source\n'
            '\t File: {}, Function: {}\n'
            '\t pc: {}, trigger: "{}":\n'
            '\t description: {}\n'
            'Sink\n'
            '\t File: {}, Function: {}\n'
            '\t pc: {}, trigger: "{}", param idx: {}\n'
            "Taint propagation\n{}".format(
                self.source.cfg.lua_module.module_name, self.source.cfg._func_name,
                self.source.high_instr.pc, self.source_trigger_word,
                source_dsp,
                self.sink.cfg.lua_module.module_name, self.sink.cfg._func_name,
                self.sink.high_instr.pc, self.sink_trigger_word, self.sink.param_idx, 
                reassigned_dsp_all
            )
        )

    def get_reassignment_str(self, sanitizer=False):
        dsp_list = list()
        for propagation_chain_dict in self.propagation_chain_list:
            if sanitizer:
                if propagation_chain_dict["type"] != VulnerabilityType.TRUE:
                    continue
            # vul_type = propagation_chain_dict["type"]
            # santizer_record = propagation_chain_dict["sanitizer"]
            propagation_chain = propagation_chain_dict["propagation_chain"]
            dsp = self.get_dsp_of_propagation(propagation_chain)
            dsp_list.append(dsp)
        return dsp_list

    def __str__(self):
        """Pretty printing of a vulnerability."""
        reassigned_dsp_list = self.get_reassignment_str()
        reassigned_dsp_all = ""
        for idx, reassigned_dsp in enumerate(reassigned_dsp_list):
            reassigned_dsp_all += "\t No.{} propagation path\n".format(idx)
            reassigned_dsp_all += reassigned_dsp

        source_dsp = ""
        if isinstance(self.source, Source_Param_Trigger):
            source_dsp = f"function param idx: {self.source.param_idx}"
        elif isinstance(self.source, Source_Ret_Trigger):
            source_dsp = f"function return idx: {self.source.return_idx}"
        else:
            raise Exception("Source type unpected")
        return (
            'Source\n'
            '\t File: {}, Function: {}\n'
            '\t pc: {}, trigger: "{}":\n'
            '\t description: {}\n'
            'Sink\n'
            '\t File: {}, Function: {}\n'
            '\t pc: {}, trigger: "{}", param idx: {}\n'
            "Taint propagation\n{}".format(
                self.source.cfg.lua_module.module_name, self.source.cfg._func_name,
                self.source.high_instr.pc, self.source_trigger_word,
                source_dsp,
                self.sink.cfg.lua_module.module_name, self.sink.cfg._func_name,
                self.sink.high_instr.pc, self.sink_trigger_word, self.sink.param_idx, 
                reassigned_dsp_all
            )
        )


class SanitisedVulnerability(Vulnerability):
    def __init__(
        self,
        confident,
        sanitiser,
        **kwargs
    ):
        super().__init__(**kwargs)
        self.confident = confident
        self.sanitiser = sanitiser

    def __str__(self):
        """Pretty printing of a vulnerability."""
        return (
            super().__str__() +
            '\nThis vulnerability is ' +
            ('' if self.confident else 'potentially ') +
            'sanitised by: ' +
            str(self.sanitiser)
        )

    def as_dict(self):
        output = super().as_dict()
        output['sanitiser'] = self.sanitiser.as_dict()
        output['confident'] = self.confident
        return output


class UnknownVulnerability(Vulnerability):
    def __init__(
        self,
        unknown_assignment,
        **kwargs
    ):
        super().__init__(**kwargs)
        self.unknown_assignment = unknown_assignment

    def as_dict(self):
        output = super().as_dict()
        output['unknown_assignment'] = self.unknown_assignment.as_dict()
        return output

    def __str__(self):
        """Pretty printing of a vulnerability."""
        return (
            super().__str__() +
            '\nThis vulnerability is unknown due to: ' +
            str(self.unknown_assignment)
        )


Sanitiser = namedtuple(
    'Sanitiser',
    (
        'trigger_word',
        'cfg_node'
    )
)


Triggers = namedtuple(
    'Triggers',
    (
        'sources',
        'sinks',
        'sanitiser_dict'
    )
)

class TriggerInstr():
    def __init__(self, source_type, idx, trigger, high_instr, secondary_nodes=[]):
        self.type = source_type # source_param/ret or sink
        self.idx = idx # idx of tainted param of source, idx of sink func param
        self.trigger_word = trigger
        self.high_instr = high_instr
        self.secondary_nodes = secondary_nodes

class TriggerNode():
    def __init__(
        self,
        trigger,
        cfg_node,
        secondary_nodes=[]
    ):
        self.trigger = trigger
        self.cfg_node = cfg_node
        self.secondary_nodes = secondary_nodes

    @property
    def trigger_word(self):
        return self.trigger.trigger_word

    @property
    def sanitisers(self):
        return self.trigger.sanitisers if hasattr(self.trigger, 'sanitisers') else []

    def append(self, cfg_node):
        if not cfg_node == self.cfg_node:
            if self.secondary_nodes and cfg_node not in self.secondary_nodes:
                self.secondary_nodes.append(cfg_node)
            elif not self.secondary_nodes:
                self.secondary_nodes = [cfg_node]

    def __repr__(self):
        output = 'TriggerNode('

        if self.trigger_word:
            output = '{} trigger_word is {}, '.format(
                output,
                self.trigger_word
            )

        return (
            output +
            'sanitisers are {}, '.format(self.sanitisers) +
            'cfg_node is {})\n'.format(self.cfg_node)
        )


def get_vulnerabilities_not_in_baseline(
    vulnerabilities,
    baseline_file
):
    baseline = json.load(open(baseline_file))
    output = list()
    for vuln in vulnerabilities:
        if vuln.as_dict() not in baseline['vulnerabilities']:
            output.append(vuln)
    return(output)


def filter_non_external_inputs(vulnerabilities):
    pattern = 'luci/controller'
    for vul in range(len(vulnerabilities)-1,-1,-1):
        if (not pattern in vulnerabilities[vul].sink.path) and (vulnerabilities[vul].source_trigger_word == 'Framework function URL parameter'):
            vulnerabilities.remove(vulnerabilities[vul])
    return(vulnerabilities)